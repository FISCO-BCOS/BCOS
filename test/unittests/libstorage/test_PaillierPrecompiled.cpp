/*
 * @CopyRight:
 * FISCO-BCOS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FISCO-BCOS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FISCO-BCOS.  If not, see <http://www.gnu.org/licenses/>
 * (c) 2016-2018 fisco-dev contributors.
 */
/** @file test_PaillierPrecompiled.cpp
 *  @author shawnhe
 *  @date 20190813
 */

#include "Common.h"
#include <libblockverifier/ExecutiveContextFactory.h>
#include <libethcore/ABI.h>
#include <libprecompiled/extension/PaillierPrecompiled.h>
#include <boost/lexical_cast.hpp>
#include <boost/test/unit_test.hpp>

using namespace dev;
using namespace dev::blockverifier;
using namespace dev::precompiled;

namespace test_PaillierPrecompiled
{
struct PaillierPrecompiledFixture
{
    PaillierPrecompiledFixture()
    {
        context = std::make_shared<ExecutiveContext>();
        paillierPrecompiled = std::make_shared<PaillierPrecompiled>();
    }

    ~PaillierPrecompiledFixture() {}

    ExecutiveContext::Ptr context;
    PaillierPrecompiled::Ptr paillierPrecompiled;
};

BOOST_FIXTURE_TEST_SUITE(test_PaillierPrecompiled, PaillierPrecompiledFixture)

BOOST_AUTO_TEST_CASE(TestHomAdd)
{
    std::string cipher1 =
        "0080932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "B6FE0709B0FFF8008B13498516BAD7F6C7453ED7C7DD0D75283A3E1D8D21D453C8F159B82A96FEBF3502ADC325"
        "CEC5750DB8029E327642E75C03A30628525E05CF0D272536432977D3981E550ADC1B2A2ACCAEBB039B1F62F1D2"
        "359A7B1D9D4B5EA6854A417FD4695A81E0D7E29319888507EADC55FC49BA2B76CF86559C770D3DD06A669CE3AF"
        "248534C85289FAE7509DE40C0E8A55E2D83F5552C99679414D4C433313C7EB296CDD0037189B00C6E9DBC33A95"
        "95A222DB990A3B7F7D6658DD532251BB160FF0C23FE691AD3240BE7A2484722EFCBB8AE10DDB7CC719B9076E39"
        "4C856800539EB71D3B82FAD9DA4529D7547BAA2EA258357A3EFE5B8B0F4F0FBD36FF0D3DD25213E78AD8319886"
        "5DFBC7B818C1D2B561E1B00F1D81B1986B7B8C72A629BBF67F5D";
    std::string cipher2 =
        "0080932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "B6FE0709B0FFF8008B13498516BAD7F6C7453ED7C7DD0D75283A3E1D8D21D453C8F159B82A96FEBF40C3573D2F"
        "F963EFB422A7C71BEDC1A8C83CEC7518489F52F1126791C40EC29E46E11C4DF515B2BF259E16233BD27B6E73BF"
        "B30E7767A9148568C0276457E00199512DBD4E24714D35C73F79434283F3C45115837669AB4E5FA62B48503A96"
        "0FCD5C3FDADBC7D8E946B3A536CF006910DC4CA50FB3044CC67B9741641B7DE3CA9F036DD58A9192FD589C3679"
        "3CBB1F541386EE84F47AEC33A26B402A0716C89C50D9F73E62C6FC4237872C0FC43B9D1FBC8C5513E8BDD1DC8A"
        "A2C6A2EF9D186A66D5FCFBC3B55D43B9E5D428C07EB4D2AE3CC98FC1CF24BFD5BCD266A924810C7C48F6EAA81C"
        "A867BB27BCCD107779E1D3CCB411F34F48A484D7C99739948D5B";
    std::string cipher3 =
        "0080932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "B6FE0709B0FFF8008B13498516BAD7F6C7453ED7C7DD0D75283A3E1D8D21D453C8F159B82A96FEBF30E42C32DA"
        "8637D04B0A1091638296FE9DB669610CF2575AB24549E34CEDEC725BE73A6888D4B0163BBF3360881EF7808C85"
        "9EFF6363AF5D087B637EC2AE4908FDDC3DB91DBE8EF489AC6658378600154A0426E4580E003518C5D3E05060C9"
        "98B29AA1D9E9A1B154E160E7FA3F14FF903837527A038C3973E0312D72EE43CD447CA8EFA4569BBF6A1C56D1FA"
        "99A7B494EABA641E977B3A063537092CF872C5FFF6C88B8BE7E92F1405EE22BAAEA60EF4B0DE755956D8981A19"
        "3330E369D351790DA56504892094777D18D5F44626597C736B4BCC6ECE99A6CACE70137773F0E0DB737B5521F4"
        "525027032AF0D92721D723CAE9DCCF001250240012602AE3FFE2";
    dev::eth::ContractABI abi;
    bytes in = abi.abiIn("paillierAdd(string,string)", cipher1, cipher2);
    bytes out = paillierPrecompiled->call(context, bytesConstRef(&in));
    std::string result;
    abi.abiOut(bytesConstRef(&out), result);
    BOOST_TEST(result == cipher3);
}

BOOST_AUTO_TEST_CASE(ErrorFunc)
{
    dev::eth::ContractABI abi;
    bytes in = abi.abiIn("add(string,string)", std::string("2AE3FFE2"), std::string("2AE3FFE2"));
    bytes out = paillierPrecompiled->call(context, bytesConstRef(&in));
    s256 count = 1;
    abi.abiOut(bytesConstRef(&out), count);
    if (g_BCOSConfig.version() > RC2_VERSION)
    {
        BOOST_TEST(count == CODE_UNKNOW_FUNCTION_CALL);
    }
    else
    {
        BOOST_TEST(count == -CODE_UNKNOW_FUNCTION_CALL);
    }
}

BOOST_AUTO_TEST_CASE(InvalidInputs)
{
    // situation1
    dev::eth::ContractABI abi;
    bytes in = abi.abiIn(
        "paillierAdd(string,string)", std::string("2AE3FFE2"), std::string("2AE3FFE22AE3FFE2"));
    bytes out = paillierPrecompiled->call(context, bytesConstRef(&in));
    s256 count = 1;
    abi.abiOut(bytesConstRef(&out), count);
    if (g_BCOSConfig.version() > RC2_VERSION)
    {
        BOOST_TEST(count == CODE_INVALID_CIPHERS);
    }
    else
    {
        BOOST_TEST(count == -CODE_INVALID_CIPHERS);
    }

    // situation2
    in = abi.abiIn("paillierAdd(string,string)", std::string("1111FFE22AE3FFE2"),
        std::string("2AE3FFE22AE3FFE2"));
    out = paillierPrecompiled->call(context, bytesConstRef(&in));
    count = 1;
    abi.abiOut(bytesConstRef(&out), count);
    if (g_BCOSConfig.version() > RC2_VERSION)
    {
        BOOST_TEST(count == CODE_INVALID_CIPHERS);
    }
    else
    {
        BOOST_TEST(count == -CODE_INVALID_CIPHERS);
    }

    // situation3
    std::string cipher3 =
        "0070932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "B6FE0709B0FFF8008B13498516BAD7F6C7453ED7C7DD0D75283A3E1D8D21D453C8F159B82A96FEBF3502ADC325"
        "CEC5750DB8029E327642E75C03A30628525E05CF0D272536432977D3981E550ADC1B2A2ACCAEBB039B1F62F1D2"
        "359A7B1D9D4B5EA6854A417FD4695A81E0D7E29319888507EADC55FC49BA2B76CF86559C770D3DD06A669CE3AF"
        "248534C85289FAE7509DE40C0E8A55E2D83F5552C99679414D4C433313C7EB296CDD0037189B00C6E9DBC33A95"
        "95A222DB990A3B7F7D6658DD532251BB160FF0C23FE691AD3240BE7A2484722EFCBB8AE10DDB7CC719B9076E39"
        "4C856800539EB71D3B82FAD9DA4529D7547BAA2EA258357A3EFE5B8B0F4F0FBD36FF0D3DD25213E78AD8319886"
        "5DFBC7B818C1D2B561E1B00F1D81B1986B7B8C72A629BBF67F5D";
    in = abi.abiIn("paillierAdd(string,string)", cipher3, cipher3);
    out = paillierPrecompiled->call(context, bytesConstRef(&in));
    count = 1;
    abi.abiOut(bytesConstRef(&out), count);
    if (g_BCOSConfig.version() > RC2_VERSION)
    {
        BOOST_TEST(count == CODE_INVALID_CIPHERS);
    }
    else
    {
        BOOST_TEST(count == -CODE_INVALID_CIPHERS);
    }

    // situation4
    std::string cipher4 =
        "0080932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "A2C6A2EF9D186A66D5FCFBC3B55D43B9E5D428C07EB4D2AE3CC98FC1CF24BFD5BCD266A924810C7C48F6EAA81C"
        "B6FE0709B0FFF8008B13498516BAD7F6C7453ED7C7DD0D75283A3E1D8D21D453C8F159B82A96FEBF3502ADC325"
        "CEC5750DB8029E327642E75C03A30628525E05CF0D272536432977D3981E550ADC1B2A2ACCAEBB039B1F62F1D2"
        "359A7B1D9D4B5EA6854A417FD4695A81E0D7E29319888507EADC55FC49BA2B76CF86559C770D3DD06A669CE3AF"
        "248534C85289FAE7509DE40C0E8A55E2D83F5552C99679414D4C433313C7EB296CDD0037189B00C6E9DBC33A95"
        "95A222DB990A3B7F7D6658DD532251BB160FF0C23FE691AD3240BE7A2484722EFCBB8AE10DDB7CC719B9076E39"
        "4C856800539EB71D3B82FAD9DA4529D7547BAA2EA258357A3EFE5B8B0F4F0FBD36FF0D3DD25213E78AD8319888"
        "CEC5750DB8029E327642E75C03A30628525E05CF0D272536432977D3981E550ADC1B2A2ACCAEBB039B1F62F1D2"
        "359A7B1D9D4B5EA6854A417FD4695A81E0D7E29319888507EADC55FC49BA2B76CF86559C770D3DD06A669CE3AF"
        "248534C85289FAE7509DE40C0E8A55E2D83F5552C99679414D4C433313C7EB296CDD0037189B00C6E9DBC33A95"
        "95A222DB990A3B7F7D6658DD532251BB160FF0C23FE691AD3240BE7A2484722EFCBB8AE10DDB7CC719B9076E39"
        "4C856800539EB71D3B82FAD9DA4529D7547BAA2EA258357A3EFE5B8B0F4F0FBD36FF0D3DD25213E78AD831988";
    in = abi.abiIn("paillierAdd(string,string)", cipher4, cipher4);
    out = paillierPrecompiled->call(context, bytesConstRef(&in));
    count = 1;
    abi.abiOut(bytesConstRef(&out), count);
    if (g_BCOSConfig.version() > RC2_VERSION)
    {
        BOOST_TEST(count == CODE_INVALID_CIPHERS);
    }
    else
    {
        BOOST_TEST(count == -CODE_INVALID_CIPHERS);
    }

    // situation5
    std::string cipher51 =
        "0080932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "CEC5750DB8029E327642E75C03A30628525E05CF0D272536432977D3981E550ADC1B2A2ACCAEBB039B1F62F1D2"
        "359A7B1D9D4B5EA6854A417FD4695A81E0D7E29319888507EADC55FC49BA2B76CF86559C770D3DD06A669CE3AF"
        "248534C85289FAE7509DE40C0E8A55E2D83F5552C99679414D4C433313C7EB296CDD0037189B00C6E9DBC33A95"
        "95A222DB990A3B7F7D6658DD532251BB160FF0C23FE691AD3240BE7A2484722EFCBB8AE10DDB7CC719B9076E39"
        "4C856800539EB71D3B82FAD9DA4529D7547BAA2EA258357A3EFE5B8B0F4F0FBD36FF0D3DD25213E78AD8319886"
        "5DFBC7B818C1D2B561E1B00F1D81B1986B7B8C72A629BBF67F5D";
    std::string cipher52 =
        "0080932D5857D9FCFD8CEEDB7593F6EAF8CD192447C6CA2F5AAA27971A19CCE957CC5E30AE56FE79DD7EC125C4"
        "AC9DE23884C58F229D1A08B56DD6C4DA8844DDFBA51AE81DC45E5F280B65BC69404370E6617DB7CEF45C12912D"
        "B6FE0709B0FFF8008B13498516BAD7F6C7453ED7C7DD0D75283A3E1D8D21D453C8F159B82A96FEBF3502ADC325"
        "CEC5750DB8029E327642E75C03A30628525E05CF0D272536432977D3981E550ADC1B2A2ACCAEBB039B1F62F1D2"
        "359A7B1D9D4B5EA6854A417FD4695A81E0D7E29319888507EADC55FC49BA2B76CF86559C770D3DD06A669CE3AF"
        "248534C85289FAE7509DE40C0E8A55E2D83F5552C99679414D4C433313C7EB296CDD0037189B00C6E9DBC33A95"
        "95A222DB990A3B7F7D6658DD532251BB160FF0C23FE691AD3240BE7A2484722EFCBB8AE10DDB7CC719B9076E39"
        "4C856800539EB71D3B82FAD9DA4529D7547BAA2EA258357A3EFE5B8B0F4F0FBD36FF0D3DD25213E78AD8319886"
        "5DFBC7B818C1D2B561E1B00F1D81B1986B7B8C72A629BBF67F5D";
    in = abi.abiIn("paillierAdd(string,string)", cipher51, cipher52);
    out = paillierPrecompiled->call(context, bytesConstRef(&in));
    count = 1;
    abi.abiOut(bytesConstRef(&out), count);
    if (g_BCOSConfig.version() > RC2_VERSION)
    {
        BOOST_TEST(count == CODE_INVALID_CIPHERS);
    }
    else
    {
        BOOST_TEST(count == -CODE_INVALID_CIPHERS);
    }
}

BOOST_AUTO_TEST_SUITE_END()

}  // namespace test_PaillierPrecompiled
